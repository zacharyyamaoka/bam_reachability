#!/usr/bin/env python3

import numpy as np
import open3d as o3d

"""
Generated by Chat GPT

- See relevant Open3D example: https://www.open3d.org/docs/latest/tutorial/visualization/interactive_visualization.html

"""
class AlignedSlicer:
    def __init__(self, points, step=0.05):
        self.points = points
        self.step = step

        self.modes = [None, 'x', 'y', 'z']
        self.mode_index = 0
        self.axis = self.modes[self.mode_index]

        self.pcd = o3d.geometry.PointCloud()
        self.vis = o3d.visualization.VisualizerWithKeyCallback()
        self.frame = o3d.geometry.TriangleMesh.create_coordinate_frame(size=0.1)

        self.vis.register_key_callback(262, self.next_slice)  # →
        self.vis.register_key_callback(263, self.prev_slice)  # ←
        self.vis.register_key_callback(265, self.next_slice)  # ↑
        self.vis.register_key_callback(264, self.prev_slice)  # ↓
        self.vis.register_key_callback(32, self.switch_mode)  # Space

        print("\nAligned Slicer Controls:")
        print("  [Space]    → Cycle view mode (full → x → y → z → full)")
        print("  [← / ↓]    → Previous slice (when slicing)")
        print("  [→ / ↑]    → Next slice (when slicing)")
        print("  [Esc]      → Exit viewer\n")

        self.slice_index = 0
        self.update_axis_state()

    def update_axis_state(self):
        if self.axis is None:
            self.axis_idx = None
            self.min_val = self.max_val = 0
            self.num_slices = 1
            self.slice_index = 0
        else:
            self.axis_idx = {'x': 0, 'y': 1, 'z': 2}[self.axis]
            self.min_val = np.min(self.points[:, self.axis_idx])
            self.max_val = np.max(self.points[:, self.axis_idx])
            self.num_slices = int(np.ceil((self.max_val - self.min_val) / self.step))
            self.slice_index = self.num_slices // 2

    def get_slice_points(self):
        if self.axis is None:
            return self.points  # Show all
        axis_col = self.points[:, self.axis_idx]
        center = self.min_val + self.slice_index * self.step
        mask = (axis_col >= center - self.step / 2) & (axis_col < center + self.step / 2)
        return self.points[mask]

    def update_view(self):
        slice_points = self.get_slice_points()
        self.pcd.points = o3d.utility.Vector3dVector(slice_points)
        self.vis.update_geometry(self.pcd)

    def next_slice(self, vis):
        if self.axis is not None:
            self.slice_index = min(self.slice_index + 1, self.num_slices - 1)
            self.update_view()

    def prev_slice(self, vis):
        if self.axis is not None:
            self.slice_index = max(self.slice_index - 1, 0)
            self.update_view()

    def switch_mode(self, vis):
        self.mode_index = (self.mode_index + 1) % len(self.modes)
        self.axis = self.modes[self.mode_index]
        print(f"Switched to mode: {self.axis if self.axis else 'full'}")
        self.update_axis_state()
        self.update_view()

    def run(self):
        self.pcd.points = o3d.utility.Vector3dVector(self.get_slice_points())
        self.vis.create_window()
        self.vis.add_geometry(self.pcd)
        self.vis.add_geometry(self.frame)
        self.vis.run()
        self.vis.destroy_window()

# Example usage
if __name__ == "__main__":

    from bam_reachability.generators import donut_generator, rectangular_generator, spherical_generator


    points = rectangular_generator(scale=(1.0, 1.0, 1.0), step=0.1)
    points = spherical_generator(diameter=1.0, step=0.1, sign=1)
    points = donut_generator(inner_diameter=0.5, outer_diameter=1.0, step=0.05)

    slicer = AlignedSlicer(points, step=0.05)
    slicer.run()

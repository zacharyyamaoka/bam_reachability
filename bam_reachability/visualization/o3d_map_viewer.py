#!/usr/bin/env python3

import numpy as np
import open3d as o3d
from typing import Optional
"""
Generated by Chat GPT

- See relevant Open3D example: https://www.open3d.org/docs/latest/tutorial/visualization/interactive_visualization.html

"""
class O3DMapViewer:
    def __init__(self, points, step=0.05, colors: Optional[np.ndarray] = None, rainbow=True, hide_alpha=False, point_size=20.0):
        """
        points: (N, 3) point cloud
        step: slice thickness (m)
        colors: (N, 3) optional RGB float values in [0, 1]
        hide_alpha: if True, hide points with alpha = 0.0
        """
        self.points = points
        self.colors = colors
        self.rainbow = rainbow
        self.hide_alpha = hide_alpha
        self.step = step
        self.point_size = point_size

        self.modes = [None, 'x', 'y', 'z']
        self.mode_index = 0
        self.axis = self.modes[self.mode_index]

        self.pcd = o3d.geometry.PointCloud()
        self.vis = o3d.visualization.VisualizerWithKeyCallback()
        self.frame = o3d.geometry.TriangleMesh.create_coordinate_frame(size=0.1)



        self.vis.register_key_callback(262, self.next_slice)  # →
        self.vis.register_key_callback(263, self.prev_slice)  # ←
        self.vis.register_key_callback(265, self.next_slice)  # ↑
        self.vis.register_key_callback(264, self.prev_slice)  # ↓
        self.vis.register_key_callback(32, self.switch_mode)  # Space

        print("\nAligned Slicer Controls:")
        print("  [Space]    → Cycle view mode (full → x → y → z → full)")
        print("  [← / ↓]    → Previous slice (when slicing)")
        print("  [→ / ↑]    → Next slice (when slicing)")
        print("  [Esc]      → Exit viewer") 
        print("  [+ / -]    → Change point size") #https://stackoverflow.com/questions/73236168/changing-the-size-of-open3d-point-cloud

        self.slice_index = 0
        self.update_axis_state()

    def update_axis_state(self):
        if self.axis is None:
            self.axis_idx = None
            self.min_val = self.max_val = 0
            self.num_slices = 1
            self.slice_index = 0
        else:
            self.axis_idx = {'x': 0, 'y': 1, 'z': 2}[self.axis]
            self.min_val = np.min(self.points[:, self.axis_idx])
            self.max_val = np.max(self.points[:, self.axis_idx])
            self.num_slices = int(np.ceil((self.max_val - self.min_val) / self.step))
            self.slice_index = self.num_slices // 2

    def get_slice_points_and_colors(self):
        if self.axis is None:
            points = self.points
            colors = self.colors
        else:
            axis_col = self.points[:, self.axis_idx]
            center = self.min_val + self.slice_index * self.step
            mask = (axis_col >= center - self.step / 2) & (axis_col < center + self.step / 2)
            points = self.points[mask]
            colors = self.colors[mask] if self.colors is not None else None

        # Handle alpha channel
        if colors is not None and colors.shape[1] == 4:
            alpha = colors[:, 3]
            if self.hide_alpha:
                valid = alpha > 0.0
                points = points[valid]
                colors = colors[valid][:, :3]
            else:
                colors = np.where(alpha[:, None] > 0, colors[:, :3], 0.0)

        return points, colors

    def update_view(self):
        slice_points, slice_colors = self.get_slice_points_and_colors()
        self.pcd.points = o3d.utility.Vector3dVector(slice_points)
        if slice_colors is not None:
            self.pcd.colors = o3d.utility.Vector3dVector(slice_colors)
        elif not self.rainbow:
            self.pcd.colors = o3d.utility.Vector3dVector(np.ones_like(slice_points))  # white
        self.vis.update_geometry(self.pcd)

    def next_slice(self, vis):
        if self.axis is not None:
            self.slice_index = min(self.slice_index + 1, self.num_slices - 1)
            self.update_view()

    def prev_slice(self, vis):
        if self.axis is not None:
            self.slice_index = max(self.slice_index - 1, 0)
            self.update_view()

    def switch_mode(self, vis):
        self.mode_index = (self.mode_index + 1) % len(self.modes)
        self.axis = self.modes[self.mode_index]
        print(f"Switched to mode: {self.axis if self.axis else 'full'}")
        self.update_axis_state()
        self.update_view()

    def run(self):
        points, colors = self.get_slice_points_and_colors()
        self.pcd.points = o3d.utility.Vector3dVector(points)
        if colors is not None:
            self.pcd.colors = o3d.utility.Vector3dVector(colors)
        elif not self.rainbow:
            self.pcd.colors = o3d.utility.Vector3dVector(np.ones_like(points))  # white
        self.vis.create_window()
        self.vis.add_geometry(self.pcd)
        self.vis.add_geometry(self.frame)
        render_option = self.vis.get_render_option()
        render_option.point_size = self.point_size 
        self.vis.run()
        self.vis.destroy_window()


# Example usage
if __name__ == "__main__":

    from bam_reachability.generators import donut_point_generator, rectangle_point_generator, sphere_point_generator


    points = rectangle_point_generator(scale=(1.0, 1.0, 1.0), step=0.1)
    points = sphere_point_generator(diameter=1.0, step=0.1, sign=1)
    points = donut_point_generator(inner_diameter=0.5, outer_diameter=1.0, step=0.02)

    colors = None
    if False:
        points = donut_point_generator(inner_diameter=0.3, outer_diameter=1.0, step=0.02)

        # Step 1: Compute XYZ radial distance from origin
        r = np.linalg.norm(points, axis=1)

        # Step 2: Normalize r between inner and outer radius
        inner_r = 0.3 / 2
        outer_r = 1.0 / 2
        r_norm = (r - inner_r) / (outer_r - inner_r)
        r_norm = np.clip(r_norm, 0.0, 1.0)

        # Step 3: Map to Red → Blue
        colors = np.stack([
            1 - r_norm,     # Red channel (strong at center)
            np.zeros_like(r_norm),
            r_norm          # Blue channel (strong at edge)
        ], axis=1)

    # Visualize
    slicer = O3DMapViewer(points, step=0.05, colors=colors)
    slicer.run()